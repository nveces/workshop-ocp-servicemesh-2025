= Lab 1 - Envoy Filters

== Introduction

Envoy exposes a set of APIs that let users and control planes statically and dynamically configure the proxy. By configuring a Listener, users can enable the flow of traffic through the proxy, and then enhance the data flow using several Filters.

As the name suggests, a Listener allows Envoy to listen to network traffic at a configured address. Each Listener then defines a set of filters that sit in the data path, collectively forming a filter chain. By composing and arranging a set of filters, users can configure Envoy to translate protocol messages, generate statistics, perform RBAC, etc.

Envoy provides numerous built-in filters, and it also provides APIs to let you create your own.

=== {ef} Object

Istio {ef} objects provide a mechanism to customize the Envoy configuration generated by Istio Pilot. 

You can use an {ef} object to modify values for certain fields, add specific filters, or even add entirely new listeners, clusters, etc. This feature must be used with care, as incorrect configurations could potentially destabilize the entire mesh. 

IMPORTANT: {efs} are not officially supported in {ossm}. {efs} can be created in {ocp} by referring to the Istio documentation https://istio.io/v1.6/docs/reference/config/networking/envoy-filter/[here, window="_blank"] but any configuration issues are not officially supported: https://access.redhat.com/solutions/5672521[window="_blank"]

Unlike other Istio networking objects, {efs} are additively applied. Any number of {efs} can exist for a given workload in a specific namespace. The order of application of these {efs} is as follows: all {efs} in the control plane namespace, followed by all matching {efs} in the workload’s namespace.

Some aspects of this API is deeply tied to the internal implementation in {ossm} networking subsystem as well as Envoy’s XDS API. While the {ef} API by itself will maintain backward compatibility, any Envoy configuration provided through this mechanism should be carefully monitored across {ossm} version upgrades, to ensure that deprecated fields are removed and replaced appropriately.

When multiple {efs} are bound to the same workload in a given namespace, all patches will be processed sequentially in order of creation time. The behavior is undefined if multiple {ef} configurations conflict with each other.

=== Lab

In the following lab you will deploy https://httpbin.org[httpbin.org, window="_blank"] in {ossm} and then modify its behavior by adding some {efs} to manipulate headers.

== Deploy httpbin using an {ig}

The following steps will deploy all necessary objects to run _httpbin_ in {ossm}.

A {gw}, {vs} and {r} for the {ig} will also be created. Take a look at the `httpbin/httpbin.yaml` and `httpbin/httpbin-route.yaml` files to understand what objects are being created.

Deploy the application in your namespace:

[source,bash]
----
oc process -f httpbin/httpbin.yaml \
    -p HTTPBIN_ROUTE="${OCP_HTTPBIN_HOST}" -n ${OCP_NAMESPACE} \
    | oc apply -n ${OCP_NAMESPACE} -f -
----

You will create a route in the `istio-system` namespace to expose the _httpbin_ service through an Ingress Gateway:

[source,bash]
----
oc process -f httpbin/httpbin-route.yaml \
    -p HTTPBIN_ROUTE_NAME="${OCP_USER}-httpbin" -p HTTPBIN_ROUTE="${OCP_HTTPBIN_HOST}" \
    -n ${OCP_NAMESPACE} \
    | oc apply -n istio-system -f -
----

Wait some seconds for all the pods to be ready:

[source,bash]
----
watch oc get pods -n ${OCP_NAMESPACE}
----

Verify that the application is reachable and is running ok:

[source,bash]
----
curl -s -kI "https://${OCP_HTTPBIN_HOST}"
----

.httpbin service working
image::httpbin_curl.png[]

.httpbin service through an {ig}
image::ingress_httpbin.png[]

== Test httpbin with a custom header

The _httpbin_ app offers and endpoint that returns anything passed in requests data.

In this example, you are going to query this endpoint using an additional custom header. Now that you have the app deployed you can try this by running the following command:

[source,bash]
----
curl -k -H "My-Header: my-value" "https://${OCP_HTTPBIN_HOST}/anything"
----

As you can see, _httpbin_ app returns a JSON with everything that was passed in the request, including your custom header:

.httpbin returns a custom header
image::httpbin_header_1.png[]

== Add an {ef} to create a new header

Let's suppose that you need to manipulate this custom header in {ossm} before the request reaches the actual _httpbin_ service. This is something that cannot be performed with regular Istio objects but can be performed with an {ef}.

You have two options: develop your own Envoy Filter in C++ like in https://github.com/envoyproxy/envoy-filter-example[this example, window="_blank"], or use the existing Envoy Lua filter to programmatically create the desired behavior by using a Lua script.

For simplicity reasons, in this lab you will use the second approach.

This {ef} will check if the custom header exists in the requests and then it will create an additional custom header with the same value of our original header.

[source,yaml]
----
apiVersion: networking.istio.io/v1alpha3
kind: EnvoyFilter
metadata:
  name: httpbin-add-custom-header
spec:
  configPatches:
  - applyTo: HTTP_FILTER <1>
    match:
      context: SIDECAR_INBOUND <2>
      listener:
        filterChain:
          filter:
            name: envoy.filters.network.http_connection_manager <3>
    patch:
      operation: INSERT_BEFORE <4>
      value:
        name: lab.httpbin_add_header <5>
        typed_config:
          '@type': type.googleapis.com/envoy.extensions.filters.http.lua.v3.Lua <6>
          inlineCode: | 
            function envoy_on_request(request_handle) <7>
              request_handle:logDebug("Running Lua filter: lab.httpbin_add_header")
              
              header = request_handle:headers():get("My-Header")

              if (header)
              then
                request_handle:logDebug("Adding header My-New-Header: " .. header)
                request_handle:headers():add("My-New-Header", header)
              end
            end
  workloadSelector: <8>
    labels:
      app: httpbin
----

<1> Specifies where in the Envoy configuration, the patch should be applied.
<2> Selects a class of configurations based on the traffic flow direction and workload type.
<3> Match a specific filter chain in a listener. 
<4> Operation denotes how the patch should be applied to the selected configuration. In this case it will insert this filter before the selected filter or sub filter.
<5> The name of this filter.
<6> The implementation type of the filter. It should be one of those provided by Envoy or any other developed and added by the user.
<7> Lua code.
<8> Criteria used to select the specific set of pods on which this patch configuration should be applied. If omitted, the set of patches in this configuration will be applied to all workload instances in the same namespace.

TIP: To apply an {ef} resource to all workloads (sidecars and gateways) in the system, define the resource in the control plane namespace, without a _workloadSelector_.

The previous Lua code will check if the header _My-Header_ already exists in the request and then will add a new header _My-New-Header_ with the same value of _My-Header_.

Note that there are some logging commands in the Lua script. This log traces will appear in the "lua" logger of the Envoy proxy.

To test it, create this {ef} in your namespace:

[source,bash]
----
oc apply -f lab1/envoyfilter-add-header.yaml -n ${OCP_NAMESPACE}
----

Now run the same query with your custom header again:

[source,bash]
----
curl -k -H "My-Header: my-value" "https://${OCP_HTTPBIN_HOST}/anything"
----

NOTE: It may take some seconds for the configuration to propagate through the mesh before you see it working.

You should see your custom header and the additional header that was created in the {ef}:

.httpbin returns a new header created in the {ef}
image::httpbin_header_2.png[]

You can check wether your filter has been inserted in the filter chain by looking at the Envoy config. In order to do this you can use _istioctl_:

[source,bash]
----
export HTTPBIN_POD=$(oc get pods --no-headers -n ${OCP_NAMESPACE} | awk '{ print $1 }' | grep httpbin)

istioctl proxy-config listeners -n ${OCP_NAMESPACE} ${HTTPBIN_POD} -o json
----

.Envoy config including the custom Lua filter
image::httpbin_envoy_config.png[]

If you don't have _istioctl_ installed you can also run the following commands:

[source,bash]
----
export HTTPBIN_POD=$(oc get pods --no-headers -n ${OCP_NAMESPACE} | awk '{ print $1 }' | grep httpbin)

oc exec -n ${OCP_NAMESPACE} -it ${HTTPBIN_POD} -c istio-proxy -- curl -X POST localhost:15000/config_dump
----

== Add an {ef} to remove the old header

Now that you have created a new header inside an {ef} based on the value of another one, let's suppose that you need to remove the old header before reaching the actual _httpbin_ service.

You can create a new filter to remove this header but it is important to notice now that these two filters are order dependent. The filter that remove the header will need to run always after the previous filter or the previous filter will never find the custom header because it have been already removed.

To make sure the removal filter is executed last, you will insert it at the end of chain.

[source,yaml]
----
apiVersion: networking.istio.io/v1alpha3
kind: EnvoyFilter
metadata:
  name: httpbin-remove-custom-header
spec:
  configPatches:
  - applyTo: HTTP_FILTER
    match:
      context: SIDECAR_INBOUND
      listener:
        filterChain:
          filter:
            name: envoy.filters.network.http_connection_manager
            subFilter:
              name: envoy.filters.http.router <1>
    patch:
      operation: INSERT_BEFORE
      value:
        name: lab.httpbin_remove_header
        typed_config:
          '@type': type.googleapis.com/envoy.extensions.filters.http.lua.v3.Lua
          inlineCode: |
            function envoy_on_request(request_handle)
              request_handle:logDebug("Running Lua filter: lab.httpbin_remove_header")
              
              header = request_handle:headers():get("My-Header")

              if (header)
              then
                request_handle:logDebug("Removing header My-Header: " .. header)
                request_handle:headers():remove("My-Header") <2>
              end
            end
  workloadSelector:
    labels:
      app: httpbin
----
<1> The filter will be inserted before the envoy.filters.http.router_ filter. _envoy.filters.http.router_ filter should always be the latest filter in the chain or Envoy will stop working.
<2> Lua code to remove the custom header.

To test it, create this {ef} in your namespace:

[source,bash]
----
oc apply -f lab1/envoyfilter-remove-header.yaml -n ${OCP_NAMESPACE}
----

Now run the same query with your custom header again:

[source,bash]
----
curl -k -H "My-Header: my-value" "https://${OCP_HTTPBIN_HOST}/anything"
----

You should see your custom header being replaced with the additional header that was created in the first {ef}, your custom header has been removed:

.httpbin returns a replaced custom header created in the {ef}
image::httpbin_header_3.png[]

You can check the position of your new filter in the filter chain by looking at the Envoy config:

[source,bash]
----
export HTTPBIN_POD=$(oc get pods --no-headers -n ${OCP_NAMESPACE} | awk '{ print $1 }' | grep httpbin)

istioctl proxy-config listeners -n ${OCP_NAMESPACE} ${HTTPBIN_POD} -o json
----

.Envoy config including the removal Lua filter at the end of the chain
image::httpbin_envoy_config_2.png[]

If you don't have _istioctl_ installed you can also run the following commands:

[source,bash]
----
export HTTPBIN_POD=$(oc get pods --no-headers -n ${OCP_NAMESPACE} | awk '{ print $1 }' | grep httpbin)

oc exec -n ${OCP_NAMESPACE} -it ${HTTPBIN_POD} -c istio-proxy -- curl -X POST localhost:15000/config_dump
----

Additionally, it is possible to review all of this information via Kiali. 

.Envoy config including the removal Lua filter at the end of the chain (Kiali)
image::httpbin_envoy_config_kiali.png[]

== Create a single {ef} to replace the header

The previous examples show how to create two different {efs} to create and remove headers.

It is possible to combine the same functionality in a single {ef}. The main purpose of separating the creation and removal of the headers was to notice the importance of the order of creation and insertion of {efs}.

In this example you are going to create an {ef} that will combine both actions.

First, remove the previous filters from your namespace:

[source,bash]
----
oc delete -f lab1/envoyfilter-add-header.yaml -n ${OCP_NAMESPACE}
oc delete -f lab1/envoyfilter-remove-header.yaml -n ${OCP_NAMESPACE}
----

This is the {ef} with the functionality combined:

[source,yaml]
----
apiVersion: networking.istio.io/v1alpha3
kind: EnvoyFilter
metadata:
  name: httpbin-replace-custom-header
spec:
  configPatches:
  - applyTo: HTTP_FILTER
    match:
      context: SIDECAR_INBOUND
      listener:
        filterChain:
          filter:
            name: envoy.filters.network.http_connection_manager <1>
    patch:
      operation: INSERT_BEFORE
      value:
        name: lab.httpbin_replace_header
        typed_config:
          '@type': type.googleapis.com/envoy.extensions.filters.http.lua.v3.Lua
          inlineCode: |
            function envoy_on_request(request_handle)
              request_handle:logDebug("Running Lua filter: lab.httpbin_replace_header")
              
              header = request_handle:headers():get("My-Header")

              if (header)
              then
                request_handle:logDebug("Replacing header My-Header with My-New-Header: " .. header)
                request_handle:headers():add("My-New-Header", header)
                request_handle:headers():remove("My-Header")
              end
            end
  workloadSelector:
    labels:
      app: httpbin
----
<1> This will be the only custom filter so you can insert this filter in any order as long as it is inserted in the correct filter chain (inbound HTTP).

To test it, create this {ef} in your namespace:

[source,bash]
----
oc apply -f lab1/envoyfilter-replace-header.yaml -n ${OCP_NAMESPACE}
----

Now run the same query with your custom header again:

[source,bash]
----
curl -k -H "My-Header: my-value" "https://${OCP_HTTPBIN_HOST}/anything"
----

You should see your custom header being replaced with the additional header and your custom header removed, but this time with only one {ef}:

.httpbin returns a replaced custom header created in the {ef}
image::httpbin_header_4.png[]

Additionally, it is possible to review all of this information via Kiali. 

.Envoy config including the removal Lua filter at the end of the chain (Kiali)
image::httpbin_envoy_config_kiali_2.png[]

== Remove Filters

Make sure you remove any {ef} you created before moving to the next lab:

[source,bash]
----
oc delete -f lab1/envoyfilter-add-header.yaml -n ${OCP_NAMESPACE}
oc delete -f lab1/envoyfilter-remove-header.yaml -n ${OCP_NAMESPACE}
oc delete -f lab1/envoyfilter-replace-header.yaml -n ${OCP_NAMESPACE}
----

include::partials/remove_httpbin.adoc[leveloffset=+1]


